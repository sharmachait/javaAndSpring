first line of defense - controlling access to the api server

we can control who can have access with
1. username and passwords
2. username and tokens
3. certificates
4. external auth providers
5. service accounts
we can control what access a user has with
1. RBAC
2. ABAC
3. Node based authorization
4. webhook mode
all communication between the internal modules of k8s is TLS encrypted

Bots and automation agents can be authorized with service accounts
Users (admins/developers) can be authorized at the kube api server level using
1. static passwords file, CSV, we can save the data in a CSV file 
2. static token file, CSV
3. certificates
4. third party auth providers

if we save the users and passwords in a CSV file we have it define it in the options for the **kube-apiserver.service** and restart the the server
or we can modify the kube-apiserver pod manifest file and add it as an option to the command
**--basic-auth-file=user-details.csv**
these must be passed as basic credentials using curl to hit kubernetes api
the user-details.csv file has password user name the id and groups
```csv
password123,user1,u0001,group1
password123,user12,u0002,group1
```
everything is same for the static token file just instead of password it stores the token and can be passed in with
**--token-auth-file=user-token.details.csv**
this token needs to be passed in the Authorization header as a Bearer token when communicating with the kube-api-server

obviously these are not recommended approaches

