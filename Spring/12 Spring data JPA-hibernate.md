JDBC still requires alot of boiler plate like with row mapper and  and passing all the parameters into the query and making prepared statements

Spring data JPA is just specification (interface) hibernate is the implementation
## important interfaces
### Repository - 
its an empty interface
it takes two generic parameters 1. the model and 2. the primary key column type
### CrudRepository
has basic methods for CRUD operations, and method to save, the save method is supposed to insert if new primary key and update if primary key already exists
### ListCrudRepository
Has List instead of an iterable wherever possible like in findall findallbyid and saveall
### PagingAndSortingRepository or ListPagingAndSortingRepository
provides methods to perform pagination and sorting when retrieving
has only two methods `Iterable<T> findAll(Sort sort);` and `Page<T> findAll(Pageable pageable);`
### JPARepository
Interface implements all these interfaces
just like MongoRepository
# Spring data JPA 
this project implements all these interfaces using hibernate

1. to be able to use the repository of a model we need to define that model as an @Entity, and annotations like @Table and @Column,
##### JPA will try to match by removing th underscore as well
use table if pojo and table name are not same same for colmun
```java

@Entity
@Table(name="contact_msg")
public class Contact extends BaseEntity{
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO, generator="native")
	@GenericGenerator(name="native", strategy="native")
	@Column(name = "contact_id")
	private int contactId;
}
```
2. how to make base entity columns part of model as well, use the annotation @MappedSuperClass
```java
@Data
@MappedSuperclass
public class BaseEntity{
	private LocalDataTime createdAt;
	private LocalDataTime updatedAt;
	private String createdBy;
	private String updatedBy;
}
```
2. Create an interface for the Model by extending one of the Repository interfaces
```java
@Repository
public interface CotactRepository extends CrudRepository<Contact,Integer>{

}
```

3. enable JPA by telling the springboot application where to find the interface and where to find the models
```java
@SpringBootApplication
@EnableJpaRepositories("com.sharmachait.wazir.repository")
@EntityScan("com.sharmachait.wazir.models")
public class Wazir {
 
}
```

4. to convert enum to String
```java
@Data
@Entity
@Table(name="holidays")
public class Holiday extends BaseEntity{
	@Id
	private String day;
	private String reason;
	@Enumerated(EnumType.STRING)
	private Type type;
	
	public enum Type{
		FESTIVAL, FEDERAL
	}
}
```

after this we can inject the ContactRepository any where we want

```java
@Service
public class ContactService {
	@Autowired
	private ContactRepository contactrepository;
	public boolean saveMessageDetails(Contact contact){
		boolean isSave = false;
		Contact savedContact = contactRepository.save(contact);
		if(saveContact != null && savedContact.getContactId() > 0){
			isSaved = true;
		}
		return isSaved;
	}
	
}
```

5. to create a repository with all the default methods
```java
@Repository
public interface HolidaysRepository extends CrudRepository<Holiday, String>{

}
```

but all the methods like findAll return an iterable instead of a list
to convert an iterable into a list
```java
Iterable<Holiday> i = holidayRepository.findAll();
List<Holidays> l = StreamSupport.stream(i.spliterator(), false).collect(Collectors.toList());
```

6. updating an entry in the data base requires us to fetch it first make changes and save again
the find methods return an Optional instead of the object
```java
public boolean updateMsg(int contactId, String updatedBy){
	boolean isUpdated  =false;
	Optional<Contact> contact = contactRepository.findById(contactId);
	contact.ifPresent(
		c -> {
			c.setStatus(ContactStatus.close);
			c.setUpdatedBy(updatedBy);
			c.updatedAt(LocalDateTime.now());
		}
	);
	Contact updatedContact = contactRepository.save(contact.get());
	if(updatedContact!=null && updatedContact.getUpdatedBy()!=null){
		isUpdated=true;
	}
	return isUpdated;
}
```

7.  how to fetch data with custom logic? based on some random fields that are not ids, we need to use ==**Derived query methods**==
we just need to define query methods in our interface, and JPA will automatically create implementations that fetches data from the database based on those parameters
```java
List<Person> findByLastName(String lastName);
Person findByEmail(String email);
Person findByEmailAndLastName(String email, String lastName);
```

```java
@Repository
public interface CotactRepository extends CrudRepository<Contact,Integer>{
	List<Contact> findByStatus(String status);
	List<Contact> findByStatusAndDate(String status, String Date);
}
```

8. to see the sql that was generated by the framework in the console your application.properties should look like this
```
spring.datasource.url=""
spring.datasource.username=admin
apring.datasource.password=somepassword
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```


## derived query methods 
the method names are made up of introducer and criteria and the two sections are divided by "By"
```java
@Repository
public interface CotactRepository extends CrudRepository<Contact,Integer>{
	List<Contact> findByStatus(String status);
	List<Contact> findByStatusAndDate(String status, String Date);
}
```
### introducers
1. find
2. read
3. query
4. count
5. get
6. distinct - `findDistinctByStatus`
we can use distinct to tell JPA to get distinct items in the output like `findDistinctByStatus`
### criteria
any of the entity properties seperated by `And` and `Or`

readBy getBy and findBy are equivalent

![[Pasted image 20241002143707.png]]
![[Pasted image 20241002144014.png]]
![[Pasted image 20241002144050.png]]

## build in auditing
for columns like createdAt, createdBy, updatedAt and updatedBy with the help of annotations

to switch on auditing
1. annotate the base entity with the required fields
```java
@Data
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity {
	
	@CreatedDate
	@Column(updatable = false)
	private LocalDateTime createdAt;
	
	@CreatedBy
	@Column(updatable = false)
	private String createdBy;
	
	@LastModifiedDate
	@Column(insertable = false)
	private LocalDateTime updatedAt;
	
	@LastModifiedBy
	@Column(insertable = false)
	private String updatedBy;
}
```

but how will the framework know what is the current time and who is logged in?

2. to let JPA know who is logged in we need to implement AuditorAware Interface and register a bean for it
```java
@Component("auditAwareImpl")
public class AuditAwareImpl implements AuditorAware<String> {
	@Override
	public Optional<String > getCurrentAuditor(){
		return Optional.ofNullable(
			SecurityContextHolder.getContext()
			.getAuthentication().getName()
			);
	}
}
```

3. enable auditing by annotating the entry point with the bean we just injected
```java
@SpringApplication
@EnableJpaRepositories("com.sharmachait.wazir")
@EntityScan("com.sharmachait.wazir.model")
@EnableJpaAuditing(auditorAwareRef = "auditAwareImpl")
public class Wazir{}
```

remember we can always expect Authentication in the method params of the controller


# custom validations for things like passwords
1. create the annotation interface
```java
@Documented
@Constraint(validatedBy = PasswordStrengthValidator.class)
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface PasswordValidator{
	String message() default "Please choose a string password";
	Class<?>[] groups() default {};
	Class<? extends Payload>[] payload() default {};
}
```
PasswordStrengthValidator is where the actual logic is implmented
### Example
For example, you might have different classes that implement the `Payload` interface:
```java
class MyPayload implements Payload { /* Implementation */ } 
class AnotherPayload implements Payload { /* Implementation */ }
```
Then you could use the `payload` attribute like this:
```java 
@PasswordValidator(payload = {MyPayload.class, AnotherPayload.class})
```

2. implement the class that has the validation logic
```java
public class PasswordStrengthValidator implements 
		ConstraintValidator<PasswordValidator, String>{
	Set<String> weakPasswords;
	@Override 
	public void initialize(PasswordValidator passwordValidator){
		weakPasswords = new HashSet<>(Arrays.asList("12345", "password", "qwerty"));
	}
	@Override
	public boolean isValid(String password, ConstraintValidatorContext ctx){
		return password!=null && (!weakPasswords.contains(password));
	}
}
```

3. use the annotation
```java
@PasswordValidator
private String pwd;
```

# another example, matching two fields like password and confirm password

if we want to perform validations on two fields the field fieldMatch and the list are required
because it takes two values it need to be mentioned on top of the class with the two values that we need to validate
```java
@Constraint(valdiatedBy = FieldsValueMathValidator.class)
@Target({ ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface fieldsValueMatch{
	String message() default "values dont match";
	Class<?>[] groups() default {};
	Class<? extends Payload>[] payload() default {};
	
	String field();
	String fieldMatch();
	
	@Target({ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	@interface List{
		FieldsValueMatch[] value();
	}
}
```

for the fieldsValueMatchValidator 
```java
public class FieldsValueMathValidator implements
		ConstraintValidator<FieldsValueMatch, Object> {
	private String field;//these are just the names of the fields
	private String fieldMatch;
	@Override
	public void initialize(FieldsValueMatch ann){
		this.field = ann.field();
		this.fieldMathc = ann.fieldMathc();
	}
	@Override
	public boolean isValid(Object value, ContrainsValidatorContext ctx){
		Object fieldValue = new BeanWrapperImpl(value).getPropertyValue(field);
			//this is just reflection
		Object fieldMatchValue = new BeanWrapperImpl(value).getPropertyValue(fieldMatch);
		if(fieldValue!=null){
			return fieldValue.equals(fieldValueMatch);
		}
		return fieldValueMatch == null;
	}
}
```

to use this multi value custom validation
```java
@Data
@Entity
@FieldsValueMatch.List({
	@FieldsValueMatch(
		field = "password",
		fieldMatch = "confirmPassword",
		message = "Passwords do not match!"
	),
	@FieldsValueMatch(
		field = "email",
		fieldMatch = "confirmEmail",
		message = "Emails do not match!"
	)
})
public class User {
	private String password;
	@Transient
	private String confirmPassword;
	@Email
	private String email;
	@Email
	@Transient
	private String confirmEmail;
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id
}
```

@Transient is used to tell JPA that 





































































